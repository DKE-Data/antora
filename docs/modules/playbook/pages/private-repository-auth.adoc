= Private Repository Authentication
:url-credential-store: https://git-scm.com/docs/git-credential-store
:url-credential-manager-plugin: https://isomorphic-git.org/docs/en/plugin_credentialManager
:url-oauth2-formats: https://isomorphic-git.org/docs/en/authentication

Antora can authenticate with private repositories using HTTP Basic authentication over HTTPS.
This document describes various ways to supply credentials to the built-in credential manager for authenticating with private repositories and how to replace the built-in credential manager with a custom one.

== Supply credentials for the default credential manager

HTTP Basic authentication requires supplying credentials to verify your identity.
Authentication credentials consist of either a username and password pair or a personal access (OAuth) token.

If you have two-factor authentication (2FA) enabled for your account, you typically have to use a token.
To create a personal access token for GitHub, see https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/[Creating a personal access token for the command line].
To create one for GitLab, see https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html[Personal access tokens].

The git client used by Antora, isomorphic-git, provides a pluggable credential manager for looking up these authentication credentials.
The credential manager fills in the authentication credentials upon request.
Antora provides a default implementation of the credential manager to use if one is not specified.

Let's find out how to supply credentials for the default credential manager to use.

=== Default credential store

Antora will look up authentication credentials automatically when requested by the git server.
By default, Antora's built-in credential manager looks for credentials in the {url-credential-store}[git credential store].
The default path for the git credential store is _$HOME/.git-credentials_ (or _$XDG_CONFIG_HOME/git/credentials_ if the previous  location doesn't exist).

The credential store is expected to have zero or more lines formatted as follows:

----
https://<credentials>@<hostname>
----

`<credentials>` consists of either a username and password pair (i.e., `username:password`) or a personal access (OAuth) token (i.e., `token:`).
`<hostname>` looks like `github.com`.

.Populate the credential store interactively
****
You can use the `git` command to populate the credential store interactively.
First, select the URL of a private repository you want to use with Antora.
Next, run the following command:

 $ git config --global credential.helper store && \
   read -p 'Repository URL: ' && \
   git ls-remote -h $REPLY > /dev/null

This command performs the following steps:

. Enables the git credential store globally
. Prompts you for the URL of a private repository
. Communicates with the private repository, which triggers a prompt for your credentials
. Stores the credentials [.path]_$HOME/.git-credentials_ (and sets the permissions to 600)

If you aren't prompted for your credentials, then your credentials are likely already stored.

Run the following command to disable the global git credential store if you don't want to leave it enabled.

 $ git config --global --remove-section credential

You can now use Antora to connect to the private repository without any further configuration.
****

When Antora needs authentication for a particular URL, it will look for an entry in the credentials store that has a matching context.
Specifically, if the protocol (e.g., `https`) and hostname match (and, optionally, the path), then the credentials are returned to the credential manager.

Here's an example entry that uses a username and password pair:

----
https://octocat:ilovegit@github.com
----

Here's an example that uses a token (mind the trailing `:` after the token):

----
https://abcdefg0123456:@github.com
----

To use different credentials for a given repository, you can append a repository path (i.e., `<repo>`) to the entry to make the matching more strict.
The `.git` file extension in the repository path is optional.

----
https://<credentials>@<hostname>/<repo>
----

Here's an example for a specific repository path:

----
https://octocat:ilovegit@github.com/octocat/Hello-World
----

To be sure this file is protected, you should immediately set its file permissions so it cannot be read by others.

 $ chmod 600 $HOME/.git-credentials

=== Custom credential store

Instead of looking for the credential store at the default path(s), you can instruct Antora to look for the file in a different location using either the `--git-credentials-path` CLI option or `GIT_CREDENTIALS_PATH` environment variable.
Here's an example that uses the CLI option:

 $ antora --git-credentials-path=./.git-credentials antora-playbook.yml

You can also specify this location directly in your playbook file under the `git` key.

.antora-playbook.yml (fragment)
[source,yaml]
----
git:
  credentials:
    path: ./.git-credentials
----

Alternately, you can embed the credentials directly into the playbook file.
However, this approach is discouraged.

.antora-playbook.yml (fragment)
[source,yaml]
----
git:
  credentials:
    contents: https://octocat:ilovegit@github.com
----

Instead of reading the credentials from a file, you can have Antora read the credentials from the environment variable named `GIT_CREDENTIALS`.
This strategy is useful in a CI environment.
In this case, the entries may be separated either by a newline character or a comma.

=== Encode credentials in URL (not recommended)

Another option for passing credentials to the credential manager is to encode them directly in the URL listed in the playbook.

WARNING: This strategy is not recommended unless you're using using a placeholder to inject the real credentials, as described at the end of this section.

Antora will extract the credentials that precede the hostname (i.e., `username:password@` or `token@`) and use them to perform authentication on your behalf if requested by the server.

Here are several examples:

.antora-playbook.yml (fragment)
[source,yaml]
----
content:
  sources:
  - url: https://GITHUB_TOKEN:x-oauth-basic@github.com:org/project-docs.git
  - url: https://oauth2:GITLAB_TOKEN@gitlab.com:org/project-docs.git
  - url: https://x-oauth-token:BITBUCKET_TOKEN@bitbucket.org:org/project-docs.git
----

NOTE: Notice that the tokens are located in different locations in the URL depending on the git host.
See {url-oauth2-formats}[OAuth2 formats^] for more details.

The drawback of this approach is that it requires putting the credentials directly into the playbook file.
Unfortunately, Antora does not yet support resolving environment variables located in the playbook file.
However, you can emulate this behavior by using a script to substitute an environment variable reference in the playbook file with its value.

Let's assume you have the following source defined in your playbook file:

.antora-playbook.yml (fragment)
[source,yaml]
----
content:
  sources:
  - url: https://$GITHUB_TOKEN:x-oauth-basic@github.com:org-name/project-docs.git
----

You can then use the following script to expand the environment variable reference, which you might run in CI prior to invoking Antora:

 $ sed -i s/\$GITHUB_TOKEN/$GITHUB_TOKEN/ antora-playbook.yml

Despite this workaround, we still recommend using the credential store integration.

== Configure a custom credential manager

The previous approaches assume that Antora can access the credentials directly, in plain text, either via a file or environment variable.
If this arrangement does not meet your security requirements, you can replace the built-in credential manager with your own.

The credential manager in Antora is an extension of the {url-credential-manager-plugin}[credentialManager plugin] in isomorphic-git.
To write a custom credential manager, you create a JavaScript object (or class) that implements the following methods:

[source,js]
----
configure ({ config, startDir })
async fill ({ url })
async approved ({ url })
async rejected ({ url, auth })
status ({ url })
----

The method that looks up the credentials is `fill`.
It must return either a `{ username, password }` or `{ token }` data object.
The `approved` and `rejected` methods are called when the credentials are approved or rejected by the server, respectively.
Note that the first and last methods are specific to Antora.
The optional `configure` method is called each time Antora starts, providing an opportunity to perform initialization steps such as defining properties.
The optional `status` method is used by Antora to look up whether authentication was requested for a given URL.

To activate your custom credential manager, first write your implementation to a dedicated JavaScript file and register it with isomorphic-git as follows:

.custom-credential-manager.js
[source,js]
----
const git = require('isomorphic-git')

git.cores.create('antora').set('credentialManager', {
  async fill ({ url }) { ... },
  async approved ({ url }) { ... },
  async rejected ({ url, auth }) { ... },
})
----

Then pass this file to the `-r` option when running Antora:

 $ antora -r ./custom-credential-manager.js antora-playbook.yml

=== Get credentials from git

Git offers a command named `git credential` that serves as a simple interface for storing and retrieving credentials from system-specific helpers in the same manner as git itself.
It can also prompt the user for a username and password.
We can use this command in a custom credential manager to allow Antora to delegate to git to look up credentials (and thus integrate with the user's own git settings).

Let's start by creating a helper function that interfaces with the system git via `git credentials fill` to retrieve the credentials for a URL:

[source,js]
----
const git = require('isomorphic-git')
const { spawn } = require('child_process')
const { URL } = require('url')

function gitCredentialFill (url) {
  const { protocol, host } = new URL(url)
  return new Promise((resolve, reject) => {
    const output = []
    const process = spawn('git', ['credential', 'fill'])
    process.on('close', (code) => {
      if (code) return reject(code)
      const { username, password } = output.join('\n').split('\n').reduce((acc, line) => {
        if (line.startsWith('username') || line.startsWith('password')) {
          const [ key, val ] = line.split('=')
          acc[key] = val
        }
        return acc
      }, {})
      resolve(password ? { username, password } : username ? { token: username } : undefined)
    })
    process.stdout.on('data', (data) => output.push(data.toString().trim()))
    process.stdin.write(`protocol=${protocol.slice(0, -1)}\nhost=${host}\n\n`)
  })
}
----

Next, let's create a credential manager that uses this function to retrieve the credentials:

[source,js]
----
const systemGitCredentialManager = {
  configure () {
    this.urls = []
  },
  async fill ({ url }) {
    this.urls.push(url)
    return gitCredentialFill(url)
  },
  async approved ({ url }) {},
  async rejected ({ url, auth }) {
    const data = { statusCode: 401, statusMessage: 'HTTP Basic: Access Denied' }
    const err = new Error(`HTTP Error: ${data.statusCode} ${data.statusMessage}`)
    err.name = err.code = 'HTTPError'
    err.data = data
    err.rejected = !!auth
    throw err
  },
  status ({ url }) {
    return this.urls.includes(url)
  },
}
----

Finally, we need to register the credential manager with isomorphic-git:

[source,js]
----
git.cores.create('antora').set('credentialManager', systemGitCredentialManager)
----

If we require this script when invoking Antora, Antora will delegate to the system git to fill the credentials:

 $ antora -r ./system-git-credential-manager.js antora-playbook.yml

It's left up to an exercise for the reader to store or erase the credentials based on whether they were approved or rejected by the server (hint: use the `approved` and `rejected` methods to invoke `git credential` again).

[#ssh-auth]
== SSH authentication

Antora does not support public/private key authentication over SSH using an SSH agent.
Instead, Antora transparently converts SSH URLs to HTTPS URLs.
This means users don't have to update their existing playbook files, even if the playbook uses SSH URLs.
